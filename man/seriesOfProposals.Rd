% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/seriesOfProposals.R
\name{seriesOfProposals}
\alias{seriesOfProposals}
\title{seriesOfProposals()}
\usage{
seriesOfProposals(oneIterationsVoters, oneIterationsGroups,
  maximumNumberOfProposalsInASeries, silentSeries, iterationNumber)
}
\arguments{
\item{oneIterationsVoters}{A dataframe created by genVoterLevelDataFrame(). Each row represents a voter and the columns are groupID, ui, ei.}

\item{oneIterationsGroups}{A dataframe created by genGroupLevelDataFrame. Each row represents a group and the columns are groupID, ui and ei.}

\item{maximumNumberOfProposalsInASeries}{An integer or FALSE. If an integer, it represents the maximum possible number of proposals considered by a group of voters. Note though, that even if if maximumNumberOfProposalsInASeries is set to an integer, that voting will still stop if a proposal passes for all k-majority rules being considerd. To allow the series of proposals to anly stop once all k-majority Rules have passes a proposal, set maximumNumberOfProposalsInASeries=FALSE.}

\item{silentSeries}{FALSE prints notifications to the console as each series finishes. TRUE silences the notifications.}

\item{iterationNumber}{the current iteration number taken from iterations().}
}
\value{
A list of objects: votersValuesFromEachRound, yeasEachRound, passesForWhichKMajorityEachRound, roundTheProposalPassed, numberOfProposalsConsidered, typicalVotersExternalCostOut, bestOffGroupsMeanExternalCostOut, worstOffGroupsMeanExternalCostOut)
}
\description{
Runs a series of votes/multiple alternatives following a follows a ???successive??? voting procedure. Stores all of the input parameters, generated values and output for further analysis.
In a successive procedure, the initial status quo q1 is paired against a proposal x1 in round 1. If x1 passes, voting ends. If x1 fails, q1 is paired against x2 in round 2, and so on for a total of R rounds (see Figure 5 in the paper). In a standard successive procedure, voting continues until the proposal passes or a speciific round R is reached and the proposal either passes or fails. In our study, voting continues until the proposal eventually passes, which we assure by improving the popularity of proposals in successive rounds. We also examine a few cases where some individuals are made better off and others are made worse off as the series proceeds. Continually improving proposals can be modeled in several ways. We assume that the expected utility of a group increases by an increment, groupPostFailingProposalMeanUiIncrease (alpha_gr in the paper), each round a proposal does not pass. The fnal round, R may result from a limitation in the number of proposals or a time limit, etc. To keep the analysis of decision costs simple, we assume each round imposes the same decision costs on all members of the assembly, c > 0. Voting rules which require many rounds to pass a proposal will generate more decision costs than voting rules which require few rounds.
}

